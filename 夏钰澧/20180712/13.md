//13. 罗马数字转整数思路：根据题目I 可以放在 V (5) 和 X (10) 的左边，X 可以放在 L (50) 和 C (100) 的左边C 可以放在 D (500) 和 M (1000) 的左边。由此先考虑这三种特殊情况。首先将字符串转为数组依次进行分解转换，在转换过程中只需要考虑三个位置的字符（当前字符，上一个字符，下一个字符）依次进行匹配。#include<iostream>#include<string>using namespace std;//在test函数中p为前一个字符，判断是否为IXC，是否进行减法操作。int test(char p, int num){	switch (p)	{	case 'I':	{		return num - 1;	}	case 'X':	{		return num - 10;	}	case 'C':	{		return num - 100;	}	default:		return num;	}}int romanToInt(string s){	char *temp = new char[s.length() + 1];	strcpy_s(temp, s.length() + 1, s.c_str());	int count=0;	for (int i = 0; i < s.length(); i++)	{		switch (temp[i])		{		case 'V':		{			count += test(temp[i - 1], 5);			break;		}		case 'L':		{			count += test(temp[i-1],50);			break;		}		case 'D':		{			count += test(temp[i - 1], 500);			break;		}		case 'M':		{			count += test(temp[i - 1], 1000);			break;		}		////////////后面的排除后一项直接加		case 'I':		{			if (temp[i + 1] != 'M'&&temp[i + 1] != 'L'&&temp[i + 1] != 'D'&&temp[i + 1] != 'V'&&temp[i+1]!='X')				count += 1;			break;		}		case 'X':		{			if (temp[i + 1] != 'M'&&temp[i + 1] != 'L'&&temp[i + 1] != 'D'&&temp[i + 1] != 'V')				count += 10;			if (temp[i - 1] == 'I')				count--;			break;		}		case 'C':		{			if (temp[i + 1] != 'M'&&temp[i + 1] != 'L'&&temp[i + 1] != 'D'&&temp[i + 1] != 'V')			count += 100;			if (temp[i - 1] == 'X')				count = count - 10;			break;		}		default:			break;		}	}	delete[]temp;	return count;}int main(){	cout << romanToInt("IX");	return 0;}