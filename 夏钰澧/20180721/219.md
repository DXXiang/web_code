219. 存在重复元素 II给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k解决思路：同样借助map集合完成，使用两个循环，第一个循环用于判断是否有重复元素，如果有进入第二个循环，没有重复的元素则把vector集合里的元素放进map里。在进入第二个循环后首先获得两个元素中第一个元素的下标（firstIndex），然后循环从firstIndex开始到第二个元素并找到其下标进行相减。#include<iostream>#include<vector>#include<map>using namespace std;bool containsNearbyDuplicate(vector<int>& nums, int k) {	int firstIndex = 0;	map<int, int> maps;	for (int i = 0; i < nums.size(); i++)	{		if (maps.count(nums[i]))		{			firstIndex = maps[nums[i]];			for (int j =firstIndex+1; j < nums.size(); j++)			{				int target = nums[j];				if (target == nums[i] || abs(j - i) < k)					return 1;			}		}					maps.insert(pair<int, int>(nums[i], i));	}		return 0;}int main(){	vector<int> vc = { 1,2,3,1 };	cout<<containsNearbyDuplicate(vc, 3);	return 0;}