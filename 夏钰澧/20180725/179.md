179.最大数,给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。解决思路：在 largestNumber（）函数中使用循环对集合中的元素交换位置，定义两个函数，其中 isChange(int num1,int num2)函数用来判断来自集合的num1和num2是否符合交换位置的条件，其中满足交换位置的条件有一下几种：1，num1的第一位数字小于num2的第一位数字；2，num1和num2的当前位置数字相同，num2的下一位数字大于num1的下一位数字，或者num1的下一位数字不存在而num2的下一位数字大于num1的当前数字，或者num2的下一位数字不存在，num1的下一位数字小于num2的当前数字。在定义一个函数 getNCount（int num,int n）用于获取数num的从左往右数第n位上的数字；#include<iostream>#include<vector>#include<string>using namespace std;int getNCount(int num,int n)//获得第n为的数字(从左往右){	int len = 1,tem=num;	if (tem < 10)		return tem;	else if (tem == 10)		return 1;	while (tem>10)//获得数字位数	{		len++;		tem = tem/10;	}	int *p = new int[len];	int res = 0,t=0;	while (num>10)	{		res = num % 10;		num = num / 10;		p[t] = res;		t++;	}	p[len-1] = num;	int result = -1;//返回-1可以表示在此数在第n的位置没有数	if ((len - n) != len && (len - n) > 0)		result = p[len - (n)];			delete[]p;	return result;}bool isChange(int num1,int num2)//两数是否交换位置（初始位置num1在前）{			if (getNCount(num1,1)<getNCount(num2,1))	{				return true;	}	else if (getNCount(num1, 1)>getNCount(num2, 1))	{		return false;	}	else//从第二个位置开始判断	{		for (int n = 2;; n++)		{			int n1 = getNCount(num1, n),n2= getNCount(num2, n);			if (n1 == -1 && n2 == -1)				break;			if (n1 != -1 && n2 != -1 && n2 > n1)				return true;			else if (n1 == -1 && n2 != -1 && n2 > getNCount(num1, n - 1))				return true;			else if (n1 != -1 && n2 == -1 && n1 < getNCount(num2, n - 1))				return true;		}		return false;	}}string largestNumber(vector<int>& nums){	int temp = 0;	string str = "";		//调整首位相同的数	for (int i = 0; i < nums.size() - 1; i++)	{		for (int j = i + 1; j < nums.size(); j++)		{			if (isChange(nums[i], nums[j]))			{				temp = nums[i];				nums[i] = nums[j];				nums[j] = temp;			}		}	}	for (int i = 0; i < nums.size(); i++)	{		str += to_string(nums[i]);	}	return str;}int main(){	vector<int> nums = { 10,2,12,122,120 };	cout<<largestNumber(nums);		return 0;}