268.给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。解决思路：首先考虑两种特殊情况，第一数组只包含一个数时，此时要么返回0要么返回此数加1.第二，此数组是连续的，即中间没有间断，此时若数组以0开头返回此数组的最大值加1，否则返回最小值减1。最后处理一般情况，首先引入map集合加以解决，在把数组放入map中的同时找出数组中的最大值和最小值，对于一般情况数组中会有一个数间断，则使用循环从数组最小值遍历到最大值即可。#include<iostream>#include<vector>#include<map>using namespace std;int missingNumber(vector<int>& nums){	//只包含一个数时	if (nums.size() == 1)	{		if(nums[0]==0)			return nums[0] + 1;		else		{			return 0;		}	}				map<int, int>maps;	int max = nums[0], min = nums[0];	for (int i = 0; i < nums.size(); i++)	{		maps.insert(pair<int, int>(nums[i], i));		if (nums[i] > max)			max = nums[i];		if (nums[i] < min)			min = nums[i];	}	for (int j = 0,temp=min; j < nums.size(); j++,temp++)	{		if (!maps.count(temp))			return temp;	}	//加结尾或开头。	if (min > 0)		return min - 1;	else		return max+1;}int main(){	return 0;}